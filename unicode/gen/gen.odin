package gen_unicode
import "../../lib"
import "core:fmt"

// https://www.unicode.org/reports/tr44/#UnicodeData.txt
// first column is implicit
UnicodeData :: struct {
	r:                              rune,
	Name:                           string,
	General_Category:               string,
	Canonical_Combining_Class:      string,
	Bidi_Class:                     string,
	/* https://www.unicode.org/reports/tr44/#Character_Decomposition_Mappings
	   If `<xxx>yyyy zzzz` then NFKD.
		 If `yyyy zzzz`, then NFD.
	*/
	Decomposition_Type_And_Mapping: string,
	Numeric_Type_Decimal:           string,
	Numeric_Type_Digit:             string,
	Numeric_Type_Numeric:           string,
	Bidi_Mirrored:                  string,
	Unicode_1_Name:                 string,
	Comment:                        string,
	Simple_Uppercase_Mapping:       string,
	Simple_Lowercase_Mapping:       string,
	Simple_Titlecase_Mapping:       string,
}

read_file :: proc(file_path: string) -> string {
	text, ok := lib.read_file(file_path)
	fmt.assertf(ok, "Failed to read file '%v'", file_path)
	return text
}
main :: proc() {
	lib.init_console()

	/* TODO: just parse UnicodeData.txt */

	/*
	parse_file("unicode/gen/CaseFolding.txt", "unicode/case_generated.odin", proc(file: lib.FileHandle) {
		lib.write_to_file(file, "// generated by `odin run unicode/gen`\n")
		lib.write_to_file(file, "package unicode\n")
		lib.write_to_file(file, "import \"../lib\"\n")
		lib.write_to_file(file, "import \"core:fmt\"\n")
		lib.write_to_file(file, "\n")
		lib.write_to_file(file, "to_foldcase :: proc(str: string, allocator := context.temp_allocator) -> string {\n")
		lib.write_to_file(file, "  sb := lib.string_builder(allocator = allocator)\n")
		lib.write_to_file(file, "  for c in str {\n")
		lib.write_to_file(file, "    switch c {\n")
	}, proc(file: lib.FileHandle, line: string) {
		parser := CSVParser{line, 0, "; "}
		code := next_column(&parser)
		status := next_column(&parser)
		mapping := next_column(&parser)
		if status[0] == 'C' || status[0] == 'F' {
			lib.write_to_file(file, fmt.tprintf("    case 0x%v:\n", code))
			mapping_parser := CSVParser{mapping, 0, " "}
			next_value := next_column(&mapping_parser)
			for {
				lib.write_to_file(file, fmt.tprintf("      fmt.sbprint(&sb, rune(0x%v))\n", next_value))
				next_value = next_column_or_empty(&mapping_parser)
				if next_value == "" {break}
			}
		}
	}, proc(file: lib.FileHandle) {
		lib.write_to_file(file, "    }\n")
		lib.write_to_file(file, "  }\n")
		lib.write_to_file(file, "  return lib.to_string(sb)\n")
		lib.write_to_file(file, "}\n")
	})
	*/
}

CSVParser :: struct {
	line:      string,
	start:     int,
	separator: string,
}
next_column_or_empty :: proc(parser: ^CSVParser) -> (column: string) {
	i := lib.index(parser.line, parser.start, parser.separator)
	column = parser.line[parser.start:i]
	parser.start = min(i + len(parser.separator), len(parser.line))
	return
}
next_column :: proc(parser: ^CSVParser, loc := #caller_location) -> (column: string) {
	start := parser.start
	column = next_column_or_empty(parser)
	fmt.assertf(column != "", "Invalid column: %v", parser.line[parser.start:], loc = loc)
	return
}

ParseStartProc :: proc(dest_file: lib.FileHandle)
ParseProc :: proc(dest_file: lib.FileHandle, slice: string)
parse_file :: proc(src_path, dest_path: string, start_proc: ParseStartProc, parse_proc: ParseProc, end_proc: ParseStartProc) {
	src_file := read_file(src_path)
	dest_file := lib.open_file_for_writing_and_truncate(dest_path)
	start_proc(dest_file)
	i := 0
	for i < len(src_file) {
		uncommented_end := lib.index_ascii(src_file, i, "#\r\n")
		line := src_file[i:uncommented_end]
		line = lib.trim_suffix(line, " ")
		line = lib.trim_suffix(line, ";")
		if len(line) > 0 {parse_proc(dest_file, line)}
		i = lib.index_newline(src_file, uncommented_end)
		i = lib.index_ignore_newline(src_file, i)
	}
	end_proc(dest_file)
}
